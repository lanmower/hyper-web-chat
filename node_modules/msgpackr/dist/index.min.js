(function(a,b){"object"==typeof exports&&"undefined"!=typeof module?b(exports):"function"==typeof define&&define.amd?define(["exports"],b):(a=a||self,b(a.msgpackr={}))})(this,function(a){'use strict';var b=Math.floor;function c(){try{if(!H.trusted&&!O){let a=C.sharedLength||0;a<C.length&&(C.length=a)}let a=e();if(G==B)C.restoreStructures&&d(),C=null,A=null,E&&(E=null);else if(G>B){// over read
let a=new Error("Unexpected end of MessagePack data");throw a.incomplete=!0,a}else if(!O)throw new Error("Data read, but end of buffer not reached");// else more to read, but we are reading sequentially, so don't clear source yet
return a}catch(a){throw C.restoreStructures&&d(),q(),(a instanceof RangeError||a.message.startsWith("Unexpected end of buffer"))&&(a.incomplete=!0),a}}function d(){for(let a in C.restoreStructures)C[a]=C.restoreStructures[a];C.restoreStructures=null}function e(){let a=A[G++];if(160>a){if(!(128>a)){if(!(144>a)){a-=144;let b=Array(a);for(let c=0;c<a;c++)b[c]=e();return b}if(a-=128,H.mapsAsObjects){let b={};for(let c=0;c<a;c++)b[o()]=e();return b}else{let b=new Map;for(let c=0;c<a;c++)b.set(e(),e());return b}}else if(64>a)return a;else{let b=C[63&a]||H.getStructures&&g()[63&a];return b?(b.read||(b.read=f(b,63&a)),b.read()):a}}else if(192>a){// fixstr
let b=a-160;if(J>=G)return D.slice(G-I,(G+=b)-I);if(0==J&&140>B){// for small blocks, avoiding the overhead of the extract call is helpful
let a=16>b?l(b):k(b);if(null!=a)return a}return S(b)}else{let b;switch(a){case 192:return null;case 193:return N;// "never-used", return special object to denote that
case 194:return!1;case 195:return!0;case 196:// bin 8
return m(A[G++]);case 197:return b=F.getUint16(G),G+=2,m(b);case 198:return b=F.getUint32(G),G+=4,m(b);case 199:// ext 8
return n(A[G++]);case 200:return b=F.getUint16(G),G+=2,n(b);case 201:return b=F.getUint32(G),G+=4,n(b);case 202:if(b=F.getFloat32(G),2<H.useFloat32){// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
let a=_[(127&A[G])<<1|A[G+1]>>7];return G+=4,(a*b+(0<b?.5:-.5)>>0)/a}return G+=4,b;case 203:return b=F.getFloat64(G),G+=8,b;// uint handlers
case 204:return A[G++];case 205:return b=F.getUint16(G),G+=2,b;case 206:return b=F.getUint32(G),G+=4,b;case 207:return H.uint64AsNumber?72057594037927940*A[G++]+281474976710656*A[G++]+1099511627776*A[G++]+4294967296*A[G++]+16777216*A[G++]+(A[G++]<<16)+(A[G++]<<8)+A[G++]:(b=F.getBigUint64(G),G+=8,b);// int handlers
case 208:return F.getInt8(G++);case 209:return b=F.getInt16(G),G+=2,b;case 210:return b=F.getInt32(G),G+=4,b;case 211:return b=F.getBigInt64(G),G+=8,b;case 212:if(b=A[G++],114==b)return Y(63&A[G++]);else{let a=K[b];if(a)return a.read?(G++,a.read(e())):a.noBuffer?(G++,a()):a(A.subarray(G,++G));throw new Error("Unknown extension "+b)}case 213:return b=A[G],114==b?(G++,Y(63&A[G++],A[G++])):n(2);case 214:// fixext 4
return n(4);case 215:// fixext 8
return n(8);case 216:// fixext 16
return n(16);case 217:return b=A[G++],J>=G?D.slice(G-I,(G+=b)-I):T(b);case 218:return b=F.getUint16(G),G+=2,J>=G?D.slice(G-I,(G+=b)-I):U(b);case 219:return b=F.getUint32(G),G+=4,J>=G?D.slice(G-I,(G+=b)-I):V(b);case 220:return b=F.getUint16(G),G+=2,i(b);case 221:return b=F.getUint32(G),G+=4,i(b);case 222:return b=F.getUint16(G),G+=2,j(b);case 223:return b=F.getUint32(G),G+=4,j(b);default:// negative int
if(224<=a)return a-256;if(void 0===a){let a=new Error("Unexpected end of MessagePack data");throw a.incomplete=!0,a}throw new Error("Unknown MessagePack token "+a);}}}function f(a,b){function c(){// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
if(2<c.count++){let c=a.read=new Function("r","return function(){return {"+a.map(a=>Q.test(a)?a+":r()":"["+JSON.stringify(a)+"]:r()").join(",")+"}}")(e);return 0===a.highByte&&(a.read=R(b,a.read)),c();// second byte is already read, if there is one so immediately read object
}let d={};for(let b,c=0,f=a.length;c<f;c++)b=a[c],d[b]=e();return d}return c.count=0,0===a.highByte?R(b,c):c}function g(){let a=p(()=>(A=null,H.getStructures()));return C=H._mergeStructures(a,C)}function h(a){let b;if(16>a&&(b=l(a)))return b;if(64<a&&z)return z.decode(A.subarray(G,G+=a));const c=G+a,d=[];for(b="";G<c;){const a=A[G++];if(0==(128&a))d.push(a);else if(192==(224&a)){// 2 bytes
const b=63&A[G++];d.push((31&a)<<6|b)}else if(224==(240&a)){// 3 bytes
const b=63&A[G++],c=63&A[G++];d.push((31&a)<<12|b<<6|c)}else if(240==(248&a)){// 4 bytes
const b=63&A[G++],c=63&A[G++],e=63&A[G++];let f=(7&a)<<18|b<<12|c<<6|e;65535<f&&(f-=65536,d.push(55296|1023&f>>>10),f=56320|1023&f),d.push(f)}else d.push(a);4096<=d.length&&(b+=W.apply(String,d),d.length=0)}return 0<d.length&&(b+=W.apply(String,d)),b}function i(a){let b=Array(a);for(let c=0;c<a;c++)b[c]=e();return b}function j(a){if(H.mapsAsObjects){let b={};for(let c=0;c<a;c++)b[o()]=e();return b}else{let b=new Map;for(let c=0;c<a;c++)b.set(e(),e());return b}}function k(a){let b=G,c=Array(a);for(let d=0;d<a;d++){const a=A[G++];if(0<(128&a))return void(G=b);c[d]=a}return W.apply(String,c)}function l(p){if(4>p){if(!(2>p)){let d=A[G++],a=A[G++];if(0<(128&d)||0<(128&a))return void(G-=2);if(3>p)return W(d,a);let b=A[G++];return 0<(128&b)?void(G-=3):W(d,a,b)}if(0===p)return"";else{let b=A[G++];return 1<(128&b)?void(G-=1):W(b)}}else{let q=A[G++],a=A[G++],b=A[G++],c=A[G++];if(0<(128&q)||0<(128&a)||0<(128&b)||0<(128&c))return void(G-=4);if(6>p){if(4===p)return W(q,a,b,c);else{let d=A[G++];return 0<(128&d)?void(G-=5):W(q,a,b,c,d)}}else if(8>p){let d=A[G++],e=A[G++];if(0<(128&d)||0<(128&e))return void(G-=6);if(7>p)return W(q,a,b,c,d,e);let f=A[G++];return 0<(128&f)?void(G-=7):W(q,a,b,c,d,e,f)}else{let d=A[G++],e=A[G++],f=A[G++],g=A[G++];if(0<(128&d)||0<(128&e)||0<(128&f)||0<(128&g))return void(G-=8);if(10>p){if(8===p)return W(q,a,b,c,d,e,f,g);else{let h=A[G++];return 0<(128&h)?void(G-=9):W(q,a,b,c,d,e,f,g,h)}}else if(12>p){let h=A[G++],i=A[G++];if(0<(128&h)||0<(128&i))return void(G-=10);if(11>p)return W(q,a,b,c,d,e,f,g,h,i);let j=A[G++];return 0<(128&j)?void(G-=11):W(q,a,b,c,d,e,f,g,h,i,j)}else{let h=A[G++],i=A[G++],j=A[G++],k=A[G++];if(0<(128&h)||0<(128&i)||0<(128&j)||0<(128&k))return void(G-=12);if(!(14>p)){let l=A[G++],m=A[G++];if(0<(128&l)||0<(128&m))return void(G-=14);if(15>p)return W(q,a,b,c,d,e,f,g,h,i,j,k,l,m);let n=A[G++];return 0<(128&n)?void(G-=15):W(q,a,b,c,d,e,f,g,h,i,j,k,l,m,n)}if(12===p)return W(q,a,b,c,d,e,f,g,h,i,j,k);else{let l=A[G++];return 0<(128&l)?void(G-=13):W(q,a,b,c,d,e,f,g,h,i,j,k,l)}}}}}function m(a){return H.copyBuffers?// specifically use the copying slice (not the node one)
Uint8Array.prototype.slice.call(A,G,G+=a):A.subarray(G,G+=a)}function n(a){let b=A[G++];if(K[b])return K[b](A.subarray(G,G+=a));throw new Error("Unknown extension type "+b)}function o(){let a=A[G++];if(160<=a&&192>a){if(a-=160,J>=G)// if it has been extracted, must use it (and faster anyway)
return D.slice(G-I,(G+=a)-I);if(!(0==J&&180>B))return S(a)}else return G--,e();let b,c=4095&(a<<5^(1<a?F.getUint16(G):0<a?A[G]:0)),d=X[c],f=G,g=G+a-3,h=0;if(d&&d.bytes==a){for(;f<g;){if(b=F.getUint32(f),b!=d[h++]){f=1879048192;break}f+=4}for(g+=3;f<g;)if(b=A[f++],b!=d[h++]){f=1879048192;break}if(f===g)return G=f,d.string;g-=3,f=G}for(d=[],X[c]=d,d.bytes=a;f<g;)b=F.getUint32(f),d.push(b),f+=4;for(g+=3;f<g;)b=A[f++],d.push(b);// for small blocks, avoiding the overhead of the extract call is helpful
let j=16>a?l(a):k(a);return null==j?d.string=S(a):d.string=j}// the registration of the record definition extension (as "r")
// notepack defines extension 0 to mean undefined, so use that as the default here
// registration of bulk record definition?
// currentExtensions[0x52] = () =>
function p(a){let b=B,c=G,d=I,e=J,f=D,g=E,h=new Uint8Array(A.slice(0,B)),i=C,j=C.slice(0,C.length),k=H,l=O,m=a();return B=b,G=c,I=d,J=e,D=f,E=g,A=h,O=l,C=i,C.splice(0,C.length,...j),H=k,F=new DataView(A.buffer,A.byteOffset,A.byteLength),m}function q(){A=null,E=null,C=null}function r(a){K[a.type]=a.unpack?a.unpack:a}function s(a,b,c){let d=a.byteLength;if(256>d+1){var{target:e,position:f}=c(4+d);e[f++]=199,e[f++]=d+1}else if(65536>d+1){var{target:e,position:f}=c(5+d);e[f++]=200,e[f++]=d+1>>8,e[f++]=255&d+1}else{var{target:e,position:f,targetView:g}=c(7+d);// plus one for the type byte
e[f++]=201,g.setUint32(f,d+1),f+=4}// "t" for typed array
e[f++]=116,e[f++]=b,e.set(new Uint8Array(a.buffer,a.byteOffset,a.byteLength),f)}function t(a,b){let c=a.byteLength;var d,e;if(256>c){var{target:d,position:e}=b(c+2);d[e++]=196,d[e++]=c}else if(65536>c){var{target:d,position:e}=b(c+3);d[e++]=197,d[e++]=c>>8,d[e++]=255&c}else{var{target:d,position:e,targetView:f}=b(c+5);d[e++]=198,f.setUint32(e,c),e+=4}d.set(a,e)}function u(a,b,c,d){let e=a.length;return 1===e?b[c++]=212:2===e?b[c++]=213:4===e?b[c++]=214:8===e?b[c++]=215:16===e?b[c++]=216:256>e?(b[c++]=199,b[c++]=e):65536>e?(b[c++]=200,b[c++]=e>>8,b[c++]=255&e):(b[c++]=201,b[c++]=e>>24,b[c++]=255&e>>16,b[c++]=255&e>>8,b[c++]=255&e),b[c++]=d,b.set(a,c),c+=e,c}function v(a,b){// insert the ids that need to be referenced for structured clones
let c,d=6*b.length,e=a.length-d;for(b.sort((c,a)=>c.offset>a.offset?1:-1);c=b.pop();){let b=c.offset,f=c.id;a.copyWithin(b+d,b,e),d-=6;let g=b+d;// 'i'
a[g++]=214,a[g++]=105,a[g++]=f>>24,a[g++]=255&f>>16,a[g++]=255&f>>8,a[g++]=255&f,e=b}return a}function w(a){if(a.Class){if(!a.pack&&!a.write)throw new Error("Extension has no pack or write function");if(a.pack&&!a.type)throw new Error("Extension has no type (numeric code to identify the extension)");ha.unshift(a.Class),ga.unshift(a)}r(a)}function*x(a,b){const c=new ra(b);for(const d of a)yield c.pack(d)}async function*y(a,b){const c=new ra(b);for await(const d of a)yield c.pack(d)}/**
	 * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects
	 * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator
	 * @param {object} [options] - unpackr options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator}
	 */var z;try{z=new TextDecoder}catch(a){}var A,B,C,D,E,F,G=0,H={},I=0,J=0,K=[],L={useRecords:!1,mapsAsObjects:!0};class M{}const N=new M;N.name="MessagePack 0xC1";var O=!1;class P{constructor(a){a&&(!1===a.useRecords&&a.mapsAsObjects===void 0&&(a.mapsAsObjects=!0),a.structures?a.structures.sharedLength=a.structures.length:a.getStructures&&((a.structures=[]).uninitialized=!0,a.structures.sharedLength=0)),Object.assign(this,a)}unpack(a,b){if(A)// re-entrant execution, save the state and restore it after we do this unpack
return p(()=>(q(),this?this.unpack(a,b):P.prototype.unpack.call(L,a,b)));if(B=-1<b?b:a.length,G=0,J=0,D=null,A=a,F=a.dataView||(a.dataView=new DataView(a.buffer,a.byteOffset,a.byteLength)),this){if(H=this,this.structures)return C=this.structures,c();(!C||0<C.length)&&(C=[])}else H=L,(!C||0<C.length)&&(C=[]);return c()}unpackMultiple(a,b){let d,e=0;try{O=!0;let f=a.length,g=this?this.unpack(a,f):aa.unpack(a,f);if(b){for(b(g);G<f;)if(e=G,!1===b(c()))return;}else{for(d=[g];G<f;)e=G,d.push(c());return d}}catch(a){throw a.lastPosition=e,a.values=d,a}finally{O=!1,q()}}_mergeStructures(a,b){a=a||[];for(let c,d=0,e=a.length;d<e;d++)c=a[d],c&&(c.isShared=!0,32<=d&&(c.highByte=d-32>>5));for(let c in a.sharedLength=a.length,b||[])if(0<=c){let d=a[c],e=b[c];e&&(d&&((a.restoreStructures||(a.restoreStructures=[]))[c]=d),a[c]=e)}return this.structures=a}decode(a,b){return this.unpack(a,b)}}const Q=/^[a-zA-Z_$][a-zA-Z\d_$]*$/,R=(a,b)=>function(){let c=A[G++];if(0===c)return b();let d=32>a?-(a+(c<<5)):a+(c<<5),e=C[d]||g()[d];if(!e)throw new Error("Record id is not defined for "+d);return e.read||(e.read=f(e,a)),e.read()};var S=h,T=h,U=h,V=h,W=String.fromCharCode,X=Array(4096);const Y=(a,b)=>{var c=e();let d=a;void 0!==b&&(a=32>a?-((b<<5)+a):(b<<5)+a,c.highByte=b);let g=C[a];return g&&g.isShared&&((C.restoreStructures||(C.restoreStructures=[]))[a]=g),C[a]=c,c.read=f(c,d),c.read()};var Z="object"==typeof self?self:global;K[0]=()=>{},K[0].noBuffer=!0,K[101]=()=>{let a=e();return(Z[a[0]]||Error)(a[1])},K[105]=()=>{// id extension (for structured clones)
let a=F.getUint32(G-4);E||(E=new Map);let b,c=A[G];b=144<=c&&160>c||220==c||221==c?[]:{};let d={target:b};// a placeholder object
E.set(a,d);let f=e();// read the next value as the target object to id
return d.used?Object.assign(b,f):(d.target=f,f);// no cycle, can just use the returned read object
},K[112]=()=>{// pointer extension (for structured clones)
let a=F.getUint32(G-4),b=E.get(a);return b.used=!0,b.target},K[115]=()=>new Set(e());const $=["Int8","Uint8","Uint8Clamped","Int16","Uint16","Int32","Uint32","Float32","Float64","BigInt64","BigUint64"].map(a=>a+"Array");K[116]=a=>{let b=a[0],c=$[b];if(!c)throw new Error("Could not find typed array for code "+b);// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
return new Z[c](Uint8Array.prototype.slice.call(a,1).buffer)},K[120]=()=>{let a=e();return new RegExp(a[0],a[1])},K[255]=a=>{// 32-bit date extension
if(4==a.length)return new Date(1e3*(16777216*a[0]+(a[1]<<16)+(a[2]<<8)+a[3]));if(8==a.length)return new Date(((a[0]<<22)+(a[1]<<14)+(a[2]<<6)+(a[3]>>2))/1e6+1e3*(4294967296*(3&a[3])+16777216*a[4]+(a[5]<<16)+(a[6]<<8)+a[7]));if(12==a.length)// TODO: Implement support for negative
return new Date(((a[0]<<24)+(a[1]<<16)+(a[2]<<8)+a[3])/1e6+1e3*((128&a[4]?-281474976710656:0)+1099511627776*a[6]+4294967296*a[7]+16777216*a[8]+(a[9]<<16)+(a[10]<<8)+a[11]));throw new Error("Invalid timestamp length")};const _=Array(147);// this is a table matching binary exponents to the multiplier to determine significant digit rounding
for(let c=0;256>c;c++)_[c]=+("1e"+b(45.15-.30103*c));var aa=new P({useRecords:!1});const ba=aa.unpack,ca=aa.unpackMultiple,da=aa.unpack,ea={NEVER:0,ALWAYS:1,DECIMAL_ROUND:3,DECIMAL_FIT:4};let fa;try{fa=new TextEncoder}catch(a){}let ga,ha;const ia="undefined"!=typeof Buffer,ja=ia?Buffer.allocUnsafeSlow:Uint8Array,ka=ia?Buffer:Uint8Array,la=ia?4294967296:2144337920;let ma,na,oa,pa=0;const qa=Symbol("record-id");class ra extends P{constructor(a){super(a),this.offset=0;let b,c,d,e,f,g=0,h=ka.prototype.utf8Write?function(a,b,c){return ma.utf8Write(a,b,c)}:!!(fa&&fa.encodeInto)&&function(a,b){return fa.encodeInto(a,ma.subarray(b)).written},i=this;a||(a={});let j=a&&a.sequential,k=a.structures||a.saveStructures,l=a.maxSharedStructures;if(null==l&&(l=k?32:0),8160<l)throw new Error("Maximum maxSharedStructure is 8160");let m=a.maxOwnStructures;null==m&&(m=k?32:64),j&&!a.saveStructures&&(this.structures=[]);// two byte record ids for shared structures
let n=32<l||64<m+l,o=l+64,p=l+m+64;if(8256<p)throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");let q=[],r=0,s=0;this.pack=this.encode=function(a){if(ma||(ma=new ja(8192),na=new DataView(ma.buffer,0,8192),pa=0),oa=ma.length-10,2048>oa-pa?(ma=new ja(ma.length),na=new DataView(ma.buffer,0,ma.length),oa=ma.length-10,pa=0):pa=2147483640&pa+7,b=pa,f=i.structuredClone?new Map:null,c=i.structures,c){c.uninitialized&&(c=i._mergeStructures(i.getStructures()));let a=c.sharedLength||0;if(a>l)//if (maxSharedStructures <= 32 && sharedStructures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids
throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to "+c.sharedLength);if(!c.transitions){c.transitions=Object.create(null);for(let b,d=0;d<a;d++){if(b=c[d],!b)continue;let a,e=c.transitions;for(let c,d=0,f=b.length;d<f;d++)c=b[d],a=e[c],a||(a=e[c]=Object.create(null)),e=a;e[qa]=d+64}g=a}j||(c.nextId=a+64)}d&&(d=!1),e=c||[];try{// update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
if(t(a),i.offset=pa,f&&f.idsToInsert){pa+=6*f.idsToInsert.length,pa>oa&&x(pa),i.offset=pa;let a=v(ma.subarray(b,pa),f.idsToInsert);return f=null,a}return ma.subarray(b,pa);// position can change if we call pack again in saveStructures, so we get the buffer now
}finally{if(c){if(10>s&&s++,1e4<r)c.transitions=null,s=0,r=0,0<q.length&&(q=[]);else if(0<q.length&&!j){for(let a=0,b=q.length;a<b;a++)q[a][qa]=0;q=[]}if(d&&i.saveStructures){let b=c.sharedLength||l;if(c.length>b&&(c=c.slice(0,b)),!1===i.saveStructures(c,g))return i._mergeStructures(i.getStructures()),i.pack(a);g=b}}}};const t=a=>{pa>oa&&(ma=x(pa));var c,d=typeof a;if("string"==d){let b,d=a.length;b=32>d?1:256>d?2:65536>d?3:5;let e=3*d;if(pa+e>oa&&(ma=x(pa+e)),64>d||!h){let e,f,g,h=pa+b;for(e=0;e<d;e++)f=a.charCodeAt(e),128>f?ma[h++]=f:2048>f?(ma[h++]=192|f>>6,ma[h++]=128|63&f):55296==(64512&f)&&56320==(64512&(g=a.charCodeAt(e+1)))?(f=65536+((1023&f)<<10)+(1023&g),e++,ma[h++]=240|f>>18,ma[h++]=128|63&f>>12,ma[h++]=128|63&f>>6,ma[h++]=128|63&f):(ma[h++]=224|f>>12,ma[h++]=128|63&f>>6,ma[h++]=128|63&f);c=h-pa-b}else c=h(a,pa+b,e);32>c?ma[pa++]=160|c:256>c?(2>b&&ma.copyWithin(pa+2,pa+1,pa+1+c),ma[pa++]=217,ma[pa++]=c):65536>c?(3>b&&ma.copyWithin(pa+3,pa+2,pa+2+c),ma[pa++]=218,ma[pa++]=c>>8,ma[pa++]=255&c):(5>b&&ma.copyWithin(pa+5,pa+3,pa+3+c),ma[pa++]=219,na.setUint32(pa,c),pa+=4),pa+=c}else if("number"===d){if(a>>>0===a)64>a?ma[pa++]=a:256>a?(ma[pa++]=204,ma[pa++]=a):65536>a?(ma[pa++]=205,ma[pa++]=a>>8,ma[pa++]=255&a):(ma[pa++]=206,na.setUint32(pa,a),pa+=4);else if(a>>0===a)-32<=a?ma[pa++]=256+a:-128<=a?(ma[pa++]=208,ma[pa++]=a+256):-32768<=a?(ma[pa++]=209,na.setInt16(pa,a),pa+=2):(ma[pa++]=210,na.setInt32(pa,a),pa+=4);else{let b;if(0<(b=this.useFloat32)&&4294967296>a&&-2147483648<=a){ma[pa++]=202,na.setFloat32(pa,a);let c;if(4>b||// this checks for  rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
(c=a*_[(127&ma[pa])<<1|ma[pa+1]>>7])>>0===c)return void(pa+=4);// move back into position for writing a double
pa--}ma[pa++]=203,na.setFloat64(pa,a),pa+=8}}else if("object"===d){if(!a)ma[pa++]=192;else{if(f){let c=f.get(a);if(c){if(!c.id){let a=f.idsToInsert||(f.idsToInsert=[]);c.id=a.push(c)}return ma[pa++]=214,ma[pa++]=112,na.setUint32(pa,c.id),void(pa+=4)}f.set(a,{offset:pa-b})}let d=a.constructor;if(d===Object)w(a,!0);else if(d===Array){c=a.length,16>c?ma[pa++]=144|c:65536>c?(ma[pa++]=220,ma[pa++]=c>>8,ma[pa++]=255&c):(ma[pa++]=221,na.setUint32(pa,c),pa+=4);for(let b=0;b<c;b++)t(a[b])}else if(d===Map){c=a.size,16>c?ma[pa++]=128|c:65536>c?(ma[pa++]=222,ma[pa++]=c>>8,ma[pa++]=255&c):(ma[pa++]=223,na.setUint32(pa,c),pa+=4);for(let[b,c]of a)t(b),t(c)}else{for(let b,c=0,d=ga.length;c<d;c++)if(b=ha[c],a instanceof b){let b=ga[c];if(b.write)return b.type&&(ma[pa++]=212,ma[pa++]=b.type,ma[pa++]=0),void t(b.write.call(this,a));let d=ma,e=na,f=pa;ma=null;let g;try{g=b.pack.call(this,a,a=>(ma=d,d=null,pa+=a,pa>oa&&x(pa),{target:ma,targetView:na,position:pa-a}),t)}finally{d&&(ma=d,na=e,pa=f,oa=ma.length-10)}return void(g&&(g.length+pa>oa&&x(g.length+pa),pa=u(g,ma,pa,b.type)))}// no extension found, write as object
w(a,!a.hasOwnProperty)}}}else if("boolean"===d)ma[pa++]=a?195:194;else if("bigint"===d){if(a<BigInt(1)<<BigInt(63)&&a>=-(BigInt(1)<<BigInt(63)))ma[pa++]=211,na.setBigInt64(pa,a);else if(a<BigInt(1)<<BigInt(64)&&0<a)ma[pa++]=207,na.setBigUint64(pa,a);else// overflow
if(this.largeBigIntToFloat)ma[pa++]=203,na.setFloat64(pa,+a);else throw new RangeError(a+" was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");pa+=8}else if("undefined"===d)this.encodeUndefinedAsNil?ma[pa++]=192:(ma[pa++]=212,ma[pa++]=0,ma[pa++]=0);else if("function"===d)t(this.writeFunction&&this.writeFunction());else throw new Error("Unknown type: "+d)},w=!1===this.useRecords?this.variableMapSize?a=>{// this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
let b=Object.keys(a),c=b.length;16>c?ma[pa++]=128|c:65536>c?(ma[pa++]=222,ma[pa++]=c>>8,ma[pa++]=255&c):(ma[pa++]=223,na.setUint32(pa,c),pa+=4);let d;for(let e=0;e<c;e++)t(d=b[e]),t(a[d])}:(a,c)=>{ma[pa++]=222;// always using map 16, so we can preallocate and set the length afterwards
let d=pa-b;pa+=2;let e=0;for(let b in a)(c||a.hasOwnProperty(b))&&(t(b),t(a[b]),e++);ma[d++ +b]=e>>8,ma[d+b]=255&e}:/*	sharedStructures ?  // For highly stable structures, using for-in can a little bit faster
			(object, safePrototype) => {
				let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))
				let objectOffset = position++ - start
				let wroteKeys
				for (let key in object) {
					if (safePrototype || object.hasOwnProperty(key)) {
						nextTransition = transition[key]
						if (!nextTransition) {
							nextTransition = transition[key] = Object.create(null)
							nextTransition.__keys__ = (transition.__keys__ || []).concat([key])
							/*let keys = Object.keys(object)
							if 
							let size = 0
							let startBranch = transition.__keys__ ? transition.__keys__.length : 0
							for (let i = 0, l = keys.length; i++) {
								let key = keys[i]
								size += key.length << 2
								if (i >= startBranch) {
									nextTransition = nextTransition[key] = Object.create(null)
									nextTransition.__keys__ = keys.slice(0, i + 1)
								}
							}
							makeRoom(position + size)
							nextTransition = transition[key]
							target.copy(target, )
							objectOffset
						}
						transition = nextTransition
						pack(object[key])
					}
				}
				let id = transition.id
				if (!id) {
					id = transition.id = structures.push(transition.__keys__) + 63
					if (sharedStructures.onUpdate)
						sharedStructures.onUpdate(id, transition.__keys__)
				}
				target[objectOffset + start] = id
			}*/a=>{let b,c=Object.keys(a),f=e.transitions||(e.transitions=Object.create(null)),g=0;for(let d,e=0,h=c.length;e<h;e++)d=c[e],b=f[d],b||(b=f[d]=Object.create(null),g++),f=b;let h=f[qa];if(h)96<=h&&n?(ma[pa++]=(31&(h-=96))+96,ma[pa++]=h>>5):ma[pa++]=h;else{h=e.nextId,h||(h=64),h<o&&this.shouldShareStructure&&!this.shouldShareStructure(c)?(h=e.nextOwnId,!(h<p)&&(h=o),e.nextOwnId=h+1):(h>=p&&(// cycle back around
h=o),e.nextId=h+1);let a=c.highByte=96<=h&&n?h-96>>5:-1;f[qa]=h,e[h-64]=c,h<o?(c.isShared=!0,e.sharedLength=h-63,d=!0,0<=a?(ma[pa++]=(31&h)+96,ma[pa++]=a):ma[pa++]=h):(0<=a?(ma[pa++]=213,ma[pa++]=114,ma[pa++]=(31&h)+96,ma[pa++]=a):(ma[pa++]=212,ma[pa++]=114,ma[pa++]=h),g&&(r+=s*g),q.length>=m&&(q.shift()[qa]=0),q.push(f),t(c))}// now write the values
for(let b=0,d=c.length;b<d;b++)t(a[c[b]])},x=a=>{var c=Math.min,d=Math.round,e=Math.max;let f;if(16777216<a){// special handling for really large buffers
if(a-b>la)throw new Error("Packed buffer would be larger than maximum buffer size");f=c(la,4096*d(e((a-b)*(67108864<a?1.25:2),16777216)/4096))}else// faster handling for smaller buffers
f=(e(a-b<<2,ma.length-1)>>12)+1<<12;let g=new ja(f);return na=new DataView(g.buffer,0,f),ma.copy?ma.copy(g,0,b,a):g.set(ma.slice(b,a)),pa-=b,b=0,oa=g.length-10,ma=g}}useBuffer(a){// this means we are finished using our own buffer and we can write over it safely
ma=a,na=new DataView(ma.buffer,ma.byteOffset,ma.byteLength),pa=0}}ha=[Date,Set,Error,RegExp,ArrayBuffer,Object.getPrototypeOf(Uint8Array.prototype).constructor/*TypedArray*/,M],ga=[{pack(a,c){let d=a.getTime()/1e3;if((this.useTimestamp32||0===a.getMilliseconds())&&0<=d&&4294967296>d){// Timestamp 32
let{target:a,targetView:b,position:e}=c(6);a[e++]=214,a[e++]=255,b.setUint32(e,d)}else if(0<d&&17179869184>d){// Timestamp 64
let{target:b,targetView:e,position:f}=c(10);b[f++]=215,b[f++]=255,e.setUint32(f,4e6*a.getMilliseconds()+(d/1e3/4294967296>>0)),e.setUint32(f+4,d)}else{// Timestamp 96
let{target:e,targetView:f,position:g}=c(15);e[g++]=199,e[g++]=12,e[g++]=255,f.setUint32(g,1e6*a.getMilliseconds()),f.setBigInt64(g+4,BigInt(b(d)))}}},{pack(a,b,c){let d=Array.from(a),{target:e,position:f}=b(this.structuredClone?3:0);this.structuredClone&&(e[f++]=212,e[f++]=115,e[f++]=0),c(d)}},{pack(a,b,c){let{target:d,position:e}=b(this.structuredClone?3:0);this.structuredClone&&(d[e++]=212,d[e++]=101,d[e++]=0),c([a.name,a.message])}},{pack(a,b,c){let{target:d,position:e}=b(this.structuredClone?3:0);this.structuredClone&&(d[e++]=212,d[e++]=120,d[e++]=0),c([a.source,a.flags])}},{pack(a,b){this.structuredClone?s(a,16,b):t(ia?Buffer.from(a):new Uint8Array(a),b)}},{pack(a,b){let c=a.constructor;c!==ka&&this.structuredClone?s(a,$.indexOf(c.name),b):t(a,b)}},{pack(a,b){// specific 0xC1 object
let{target:c,position:d}=b(1);c[d]=193}}];let sa=new ra({useRecords:!1});const ta=sa.pack,ua=sa.pack,{NEVER:va,ALWAYS:wa,DECIMAL_ROUND:xa,DECIMAL_FIT:ya}=ea;a.ALWAYS=wa,a.C1=N,a.DECIMAL_FIT=ya,a.DECIMAL_ROUND=xa,a.Decoder=P,a.Encoder=ra,a.FLOAT32_OPTIONS=ea,a.NEVER=va,a.Packr=ra,a.Unpackr=P,a.addExtension=w,a.clearSource=q,a.decode=da,a.decodeIter=function(a,b={}){if(!a||"object"!=typeof a)throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");const c=new P(b);let d;const e=a=>{let b;// if there's incomplete data from previous chunk, concatinate and try again
d&&(a=Buffer.concat([d,a]),d=void 0);try{b=c.unpackMultiple(a)}catch(c){if(c.incomplete)d=a.slice(c.lastPosition),b=c.values;else throw c}return b};if("function"==typeof a[Symbol.iterator])return function*(){for(const b of a)yield*e(b)}();return"function"==typeof a[Symbol.asyncIterator]?async function*(){for await(const b of a)yield*e(b)}():void 0},a.encode=ua,a.encodeIter=/**
	 * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer
	 * If the argument is only Async Iterable, the return value will be an Async Iterable.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object
	 * @param {options} [options] - msgpackr pack options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator>}
	 */function(a,b={}){if(!a||"object"!=typeof a)throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");else{if("function"==typeof a[Symbol.iterator])return x(a,b);if("function"==typeof a.then||"function"==typeof a[Symbol.asyncIterator])return y(a,b);throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise")}},a.mapsAsObjects=!0,a.pack=ta,a.unpack=ba,a.unpackMultiple=ca,a.useRecords=!1,Object.defineProperty(a,"__esModule",{value:!0})});
